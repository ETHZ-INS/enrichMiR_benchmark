---
title: "Bartel enrichMiR exon analysis"
author: "tgermade"
date: "`r Sys.Date()`"
output:
    html_document:
        toc: true
        toc_float: true
        theme: 'cerulean'
        highlight: 'tango'
        df_print: paged
---

<style>
  .main-container {
    max-width: 1500px !important;
  }
</style>


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries, message=FALSE, warning=FALSE}
suppressPackageStartupMessages({
  library(SummarizedExperiment)
  library(SEtools)
  library(ggplot2)
  library(plgINS)
  library(edgeR)
})
```

## Loading

```{r bartel import, message=FALSE, warning=FALSE, eval=TRUE}

# load splice SE (the individual HeLa & HEK datasets are only used for colData generation)
se.splicing <- readRDS("data/raw/bartel.splicing.raw.SE.rds")
se.hela <- readRDS( "data/bartel.hela.DEA.SE.rds")
se.hek <- readRDS("data/bartel.hek.DEA.SE.rds")
```

```{r bartel modify, message=FALSE, warning=FALSE, eval=TRUE}

# filter raw data
filter <- c(10,2)
se.splicing <- se.splicing[which(rowSums(assay(se.splicing) >= filter[1]) >= filter[2]),]

# create colData info for splicing SE
colData(se.splicing) <- cbind(colData(se.splicing), rbind(colData(se.hela)[se.hela$miRNA!="CTRL",], colData(se.hek)[se.hek$miRNA!="CTRL",])[colnames(se.splicing),])

```

## DEA

```{r generate control function}

genCTRL <- function(se, readtype, logcpm){
  # e.ctrl <- sapply(unique(se$Batch), ls=min(colSums(assays(se)[[readtype]])),
  #                        FUN=function(x,ls){
  #                          rowMedians(exp(assays(se)[[logcpm]][,se$Batch==x])-1) * ls/1000000
  #                          }
  #                        )
  e.ctrl <- sapply(unique(se$Batch), ls=colSums(assays(se)[[readtype]]),
                         FUN=function(x,ls){
                           rowMedians(expm1(assays(se)[[logcpm]][,se$Batch==x])) * median(ls[se$Batch==x])/1000000
                           }
                         )

  ### generate colnames
  n.cols <- sapply( unique(se$Batch), FUN=function(x) var_name <- paste("CTRL", x, sep=".") )
  colnames(e.ctrl) <- n.cols
  rownames(e.ctrl) <- rownames(se)
  return(e.ctrl)
  }
```

```{r exon dea function, message=FALSE, warning=FALSE, eval=TRUE}


#' exonDEA
#'
#' Generates control samples out of the average values over all supplied samples, combines spliced and unspliced
#' assays, calculates their logCPM & log2FC data and performs DEA over all treatments & individual ones. 
#' All is assembled into one SE object. 
#' 
#'
#' @param se SummarizedExperiment object containing assays of raw counts of spliced & unspliced tx
#'
#' @return an SE object of combined spliced and unspliced data
#' 
exonDEA <- function(se, model, model0=~1){
  
  # allocation
  
  e1 <- assays(se)$spliced
  e2 <- assays(se)$unspliced
  readtype1 <- "spliced"
  readtype2 <- "unspliced"
  
  
  # generate control
  
  ## create logcpm assays for both spliced & unspliced assays
  assays(se)$logcpm.spliced <- log1p(cpm(calcNormFactors(DGEList(assays(se)$spliced))))
  assays(se)$logcpm.unspliced <- log1p(cpm(calcNormFactors(DGEList(assays(se)$unspliced))))

  ## generate a 'control' sample out of the median normalized counts over all samples
  e.ctrl1 <- genCTRL(se, readtype1, "logcpm.spliced")
  e.ctrl2 <- genCTRL(se, readtype2, "logcpm.unspliced")
  
  ## add control samples to assays & generate DGEList object
  dds1 <- DGEList(cbind(e1, e.ctrl1))
  dds2 <- DGEList(cbind(e2, e.ctrl2))
  
  ## combine the spliced & unspliced assays
  dds <- cbind(dds1, dds2)

  
  # generate colData
  
  ## generate colData info for combined assay
  # dd1 <- colData(se)[,c("Batch","miRNA","Cell_Line")]
  # dd.ctrl1 <- data.frame(Batch=unique(se$Batch), 
  #                        miRNA="CTRL", 
  #                        Cell_Line=unique(as.character(dd1$Cell_Line)) )
  # dd1 <- rbind(dd1, dd.ctrl1)
  # dd1$readtype <- readtype1
  
  dd1 <- rbind(colData(se)[,c("Batch","miRNA","Cell_Line")], 
               data.frame(Batch=unique(se$Batch), miRNA="CTRL", Cell_Line=unique(se$Cell_Line)))
  dd1$readtype <- readtype1
  
  ## duplicate dd to have data for combined spliced & unspliced assay
  dd <- rbind(dd1, dd1)
  dd$readtype[(nrow(dd1)+1):nrow(dd)] <- readtype2
  dd$readtype <- as.factor(dd$readtype)
  
  ## rename both dds & dd object features
  n.cols1 <- sapply(colnames(dds1), FUN=function(x)
      var_name <- paste(x, readtype1, sep=".") )
  n.cols2 <- sapply(colnames(dds2), FUN=function(x)
      var_name <- paste(x, readtype2, sep=".") )
  
  colnames(dds) <- c(n.cols1, n.cols2)
  rownames(dd) <- c(n.cols1, n.cols2)
  

  # DEA
  
  dd$miRNA <- relevel(droplevels(dd$miRNA), ref="CTRL")
  dd$readtype <- relevel(dd$readtype, ref="unspliced")
  dd$Batch <- droplevels(dd$Batch)
  ## To do the normalization
  dds <- calcNormFactors(dds)
  ## models
  mm <- model.matrix(model, data=dd)
  mm0 <- model.matrix(model0, data=dd)
  testCoeff <- setdiff(colnames(mm), colnames(mm0))
  ## estimate dispersion
  dds <- estimateDisp(dds,mm)
  ## fit negative binomial distribution on counts per gene (use glmFit for few replicates)
  fit <- glmFit(dds, mm)
  ## fit a GLM on the data
  lrt.comb <- glmLRT(fit, testCoeff)
  ## top genes that change relative to stage 0
  res.comb <- as.data.frame(topTags(lrt.comb, Inf))
  ## fit linear model dropping one sample at a time (using multiple cores)
  res.list <- bplapply( testCoeff, BPPARAM=MulticoreParam(8), FUN=function(x){
    as.data.frame(topTags(glmLRT(fit, x),Inf))
  })
  dea.names <- gsub("readtype","", testCoeff)
  dea.names <- make.names(gsub(":miRNA",".", dea.names))
  colnames(res.comb)[grepl("logFC",colnames(res.comb))] <- paste0("logFC.", dea.names)
  names(res.list) <- paste0("DEA.",dea.names)
  
  
  # generate final SE object
  
  ## SE object with logCPM & logFC assays
  se <- SummarizedExperiment(assays=list(counts=dds$counts), 
                             rowData=rowData(se), 
                             colData=dd) 
  assays(se)$logcpm <- log1p(cpm(calcNormFactors(DGEList(assay(se)))))
  se <- SEtools::log2FC(se, controls = se$miRNA=="CTRL", by = paste(se$Batch, se$readtype), fromAssay = "logcpm")

  ## add DEAs
  rowData(se)$DEA.spliced.all <- DataFrame(res.comb[rownames(se),])
  for(i in paste0("DEA.",dea.names)){
    rowData(se)[[i]] <- DataFrame(res.list[[i]][rownames(se),])
  }
  
  
  # output
  
  return(se)
}
```

```{r exon dea, message=FALSE, warning=FALSE, eval=TRUE}


# bartel hela & hek DEA with exon resolution
## combined readtype:miRNA effect
se.hela <- exonDEA(se.splicing[,se.splicing$Cell_Line=="HeLa"], 
                   model = ~readtype*miRNA, model0 = ~readtype+miRNA)
se.hek <- exonDEA(se.splicing[,se.splicing$Cell_Line=="HEK293FT"], 
                  model = ~readtype*miRNA, model0 = ~readtype+miRNA)

# miRNA effect
se.hela.test <- exonDEA(se.splicing[,se.splicing$Cell_Line=="HeLa"], 
                   model = ~readtype+miRNA, model0 = ~readtype)
se.hek.test <- exonDEA(se.splicing[,se.splicing$Cell_Line=="HEK293FT"], 
                   model = ~readtype+miRNA, model0 = ~readtype)

# miRNA & combined exon:miRNA effect
se.hela.test2 <- exonDEA(se.splicing[,se.splicing$Cell_Line=="HeLa"], 
                   model = ~readtype*miRNA, model0 = ~readtype)
se.hek.test2 <- exonDEA(se.splicing[,se.splicing$Cell_Line=="HEK293FT"], 
                   model = ~readtype*miRNA, model0 = ~readtype)

# batch effect included
se.hela.batch <- exonDEA(se.splicing[,se.splicing$Cell_Line=="HeLa"], 
                   model = ~Batch+readtype*miRNA, model0 = ~Batch+readtype+miRNA)
se.hek.batch <- exonDEA(se.splicing[,se.splicing$Cell_Line=="HEK293FT"], 
                   model = ~Batch+readtype*miRNA, model0 = ~Batch+readtype+miRNA)
```

## Plots

### HeLa

```{r heatmap hela, message=FALSE, warning=FALSE, fig.width=12, fig.height=7, eval=F}

# logFC heatmap HeLa [model = ~readtype*miRNA, model0 = ~readtype+miRNA]
SEtools::sehm(se.hela[,order(colData(se.hela)$miRNA)], row.names(se.hela)[rowData(se.hela)$DEA.spliced.all$FDR < 0.01], gaps_at = "readtype",
              breaks=T, do.scale = T, show_colnames = FALSE, assayName = "log2FC", anno_columns = c("miRNA","readtype"))
# logCPM heatmap HeLa spliced [model = ~readtype*miRNA, model0 = ~readtype+miRNA]
se.hela.sp <- se.hela[,colData(se.hela)$readtype=="spliced"]
SEtools::sehm(se.hela.sp[,order(colData(se.hela.sp)$miRNA)], row.names(se.hela.sp)[rowData(se.hela.sp)$DEA.spliced.all$FDR < 0.01], gaps_at = "readtype",
              breaks=T, do.scale = T, show_colnames = FALSE, assayName = "logcpm", anno_columns = c("miRNA","readtype"))

# batch logFC heatmap HeLa [model = ~Batch+readtype*miRNA, model0 = ~Batch+readtype+miRNA]
SEtools::sehm(se.hela.batch[,order(colData(se.hela.batch)$miRNA)], row.names(se.hela.batch)[rowData(se.hela.batch)$DEA.spliced.all$FDR < 0.01], gaps_at = "readtype",
              breaks=T, do.scale = T, show_colnames = FALSE, assayName = "log2FC", anno_columns = c("miRNA","readtype"))

# logFC heatmap HeLa [model = ~readtype+miRNA, model0 = ~readtype]
SEtools::sehm(se.hela.test[,order(colData(se.hela.test)$miRNA)], row.names(se.hela.test)[rowData(se.hela.test)$DEA.spliced.all$FDR < 0.00001], gaps_at = "readtype",
              breaks=T, do.scale = T, show_colnames = FALSE, assayName = "log2FC", anno_columns = c("miRNA","readtype"))

# logFC heatmap HeLa [model = ~readtype*miRNA, model0 = ~readtype]
SEtools::sehm(se.hela.test2[,order(colData(se.hela.test2)$miRNA)], row.names(se.hela.test2)[rowData(se.hela.test2)$DEA.spliced.all$FDR < 0.00001], gaps_at = "readtype",
              breaks=T, do.scale = T, show_colnames = FALSE, assayName = "log2FC", anno_columns = c("miRNA","readtype"))


# logCPM vs logFC scatterplot HeLa
LSD:::heatscatter(as.vector(assays(se.hela)$logcpm),as.vector(assays(se.hela)$log2FC))
abline(a=0, b=0)
```

### HEK

```{r heatmap hek, message=FALSE, warning=FALSE, fig.width=12, fig.height=7, eval=F}

# logFC heatmap HEK [model = ~readtype*miRNA, model0 = ~readtype+miRNA]
SEtools::sehm(se.hek[,order(colData(se.hek)$miRNA)], row.names(se.hek)[rowData(se.hek)$DEA.spliced.all$FDR < 0.01], gaps_at = "readtype",
              breaks=T, do.scale = T, show_colnames = FALSE, assayName = "log2FC", anno_columns = c("miRNA","readtype"))
# logCPM heatmap HEK spliced [model = ~readtype*miRNA, model0 = ~readtype+miRNA]
se.hek.sp <- se.hek[,colData(se.hek)$readtype=="spliced"]
SEtools::sehm(se.hek.sp[,order(colData(se.hek.sp)$miRNA)], row.names(se.hek.sp)[rowData(se.hek.sp)$DEA.spliced.all$FDR < 0.01], gaps_at = "readtype",
              breaks=T, do.scale = T, show_colnames = FALSE, assayName = "logcpm", anno_columns = c("miRNA","readtype"))

# batch logFC heatmap HEK [model = ~Batch+readtype*miRNA, model0 = ~Batch+readtype+miRNA]
SEtools::sehm(se.hek.batch[,order(colData(se.hek.batch)$miRNA)], row.names(se.hek.batch)[rowData(se.hek.batch)$DEA.spliced.all$FDR < 0.01], gaps_at = "readtype",
              breaks=T, do.scale = T, show_colnames = FALSE, assayName = "log2FC", anno_columns = c("miRNA","readtype"))

# logFC heatmap HEK [model = ~readtype+miRNA, model0 = ~readtype]
SEtools::sehm(se.hek.test[,order(colData(se.hek.test)$miRNA)], row.names(se.hek.test)[rowData(se.hek.test)$DEA.spliced.all$FDR < 0.00001], gaps_at = "readtype",
              breaks=T, do.scale = T, show_colnames = FALSE, assayName = "log2FC", anno_columns = c("miRNA","readtype"))

# logFC heatmap HEK [model = ~readtype*miRNA, model0 = ~readtype]
SEtools::sehm(se.hek.test2[,order(colData(se.hek.test2)$miRNA)], row.names(se.hek.test2)[rowData(se.hek.test2)$DEA.spliced.all$FDR < 0.00001], gaps_at = "readtype",
              breaks=T, do.scale = T, show_colnames = FALSE, assayName = "log2FC", anno_columns = c("miRNA","readtype"))


# logCPM vs logFC scatterplot HEK
LSD:::heatscatter(as.vector(assays(se.hek)$logcpm),as.vector(assays(se.hek)$log2FC))
abline(a=0, b=0)
```

## Stats

```{r spliced ratios, eval=F}

# spliced v unspliced HeLa
lib.hela.spliced <- apply(assays(se.hela[,colData(se.hela)$readtype=="spliced"])$counts, 2, function(x) sum(x))
lib.hela.unspliced <- apply(assays(se.hela[,colData(se.hela)$readtype=="unspliced"])$counts, 2, function(x) sum(x))

median(lib.hela.unspliced / lib.hela.spliced)

# spliced v unspliced HEK
lib.hek.spliced <- apply(assays(se.hek[,colData(se.hek)$readtype=="spliced"])$counts, 2, function(x) sum(x))
lib.hek.unspliced <- apply(assays(se.hek[,colData(se.hek)$readtype=="unspliced"])$counts, 2, function(x) sum(x))

median(lib.hek.unspliced / lib.hek.spliced)


# check number of positive & negative logFC for different significances HeLa spliced
signTables <- function(se, sig, dea){
  fc.sign <- lapply(sig, function(x) table(sign(assays(se[rowData(se)[[dea]]$FDR < x,])$log2FC)) )
  names(fc.sign) <- sig
  return(fc.sign)
}

sig <- c(1e-10, 1e-5, .05, .1, 1)
signTables(se.hela, sig, "DEA.spliced.all")
signTables(se.hek, sig, "DEA.spliced.all")
```

```{r result comparison, message=FALSE, warning=FALSE, fig.width=12, fig.height=7, eval=F}

# compare to non-exon-specific DEA results

## construct non-exon-specific SE object
### load
se.comb.hela <- readRDS("data/bartel.hela.DEA.SE.rds")
rowData(se.comb.hela) <- lapply(rowData(se.comb.hela), FUN=function(x){ if(is.data.frame(x)) x <- DataFrame(x); x} )
### only select genes common with our exon-specific dataset
common <- intersect(rowData(se.hela)$gene_name, rowData(se.comb.hela)$symbol)
se.comb.hela <- se.comb.hela[common,]

### generate control samples
e.ctrl <- genCTRL(se.comb.hela, "counts", "logcpm")

### add control samples to assays & generate DGEList object
dds <- DGEList(cbind(assay(se.comb.hela), e.ctrl))

### generate colData
dd <- colData(se.comb.hela)[,c("Batch","miRNA","Cell_Line")]
dd.ctrl <- data.frame(Batch=unique(se.comb.hela$Batch), 
                       miRNA="CTRL", 
                       Cell_Line=unique(as.character(dd$Cell_Line)) )
dd <- rbind(dd, dd.ctrl)

### generate SE & logCPM & log2FC assays
se.comb.hela <- SummarizedExperiment(assays=list(counts=dds$counts), rowData=rowData(se.comb.hela), colData=dd)
assays(se.comb.hela)$logcpm <- log1p(cpm(calcNormFactors(DGEList(assay(se.comb.hela)))))
se.comb.hela <- SEtools::log2FC(se.comb.hela, controls = se.comb.hela$miRNA=="CTRL", by = se.comb.hela$Batch, fromAssay = "logcpm")

rowData(se.comb.hela)$DEA.all <- DataFrame(FDR=unlist(
  bplapply(1:nrow(se.comb.hela), function(i){
    fdr <- sapply(rowData(se.comb.hela)[-1], function(x){
      x[[i,"FDR"]]
      })
    min(fdr)
    }, BPPARAM = MulticoreParam(8, progressbar = FALSE) )
  ), row.names = rownames(se.comb.hela) )



## logFC heatmap HEK [model = ~readtype*miRNA, model0 = ~readtype+miRNA]
SEtools::sehm(se.comb.hela[,order(colData(se.comb.hela)$miRNA)], row.names(se.comb.hela)[rowData(se.comb.hela)$DEA.all$FDR < 0.01],
              breaks=T, do.scale = T, show_colnames = FALSE, assayName = "log2FC", anno_columns = "miRNA")

## logCPM vs logFC scatterplot HeLa comb
LSD:::heatscatter(as.vector(assays(se.comb.hela)$logcpm),as.vector(assays(se.comb.hela)$log2FC))
abline(a=0, b=0)

## logFC signs at different significance levels 
signTables(se.comb.hela, sig, "DEA.all")
```


## Investigate upregulated spliced tx

```{r load enrichmir ts}

# load TS object
TS <- readRDS( "data/TargetScan_all.rds")
```

```{r load bartel treatments}

# load detailed Bartel treatment info containing exact sequences
pert <- read.csv("data/bartel_treatments.txt", sep = "\t")

# we extract HeLa & HEK data (we disregard passenger strands as long as we're working with TargetScan)
colnames(pert) <- c("treatment","seq")
pert <- list(pert[1:17,], pert[37:48,])
names(pert) <- c("hela","hek")

# find out where the seed sequence begins
#unlist(gregexpr(pattern ="GAGGUAG",pert$seq))
#unlist(gregexpr(pattern ="GGAAUGU",pert$seq))

# extract seed sequences
pert <- lapply(pert, function(x){
  seed <- data.frame(seed=sapply(x$seq, function(y) substring(y ,2, 8)))
  x <- cbind(x, seed)
})
```

```{r control analysis function}

# Check if log2FC upregulations are due to skewed controls 


ctrlAnalysis <- function(se, pert, TS){
  
  ## vector of Bartel miRNA treatments and their corresponding seeds (based on actual miRNA seqs)
  pert.fam <- sapply(se$miRNA[se$miRNA!="CTRL"], function(x){
    as.character(pert$seed[grepl(paste0(x,"$"), pert$treatment) | grepl(paste0(x,"\\("), pert$treatment)])
    })
  names(pert.fam) <- se$miRNA[se$miRNA!="CTRL"]
  
  ## adjusted gene names to be identical to TS names
  fc.genes <- sapply(rownames(se), function(x) paste(unlist(strsplit(x,"\\."))[-1], collapse ="."))
  ## only consider common genes
  id <- fc.genes %in% TS$feature
  
  ## find treatment miRNAs potentially targeting each gene
  n <- apply(sign(assays(se[id,se$miRNA!="CTRL"])$log2FC),1, function(x){
    if(max(x)>0){
      unique(pert.fam[x!=1])
    }
    })
  names(n) <- fc.genes[id]
  
  ## for each common gene select the miRNA families that target them (using TargetScan data)
  ts.list <- lapply(names(n[id]), function(x)
    TS$family[TS$feature==x]
    )
  names(ts.list) <- names(n[names(n) %in% TS$feature])
  
  ## ratio of treatment miRNA are in the TS target list
  ratios <- sapply(names(ts.list), function(x) sum(n[[x]] %in% ts.list[[x]])/length(n[[x]]) )
  
  return(list(n=n,ratios=ratios))
}
```

```{r control analysis}

# Check if log2FC upregulations are due to skewed controls 

## call function
ca.hela <- ctrlAnalysis(se.hela, pert$hela, TS)
ca.hek <- ctrlAnalysis(se.hek, pert$hek, TS)


## HeLa

### to be able to affect the controls, the combined targeting of the treatment miRNAs must be in the majority
hist(sapply(ca.hela$n, length))
abline(v=length(unique(se.hela$miRNA))/2, col="red")

### check what ratio of treatment miRNA are in the TS target list
hist(ca.hela$ratios)
mean(ca.hela$ratios, na.rm=TRUE)
median(ca.hela$ratios, na.rm=TRUE)


## HEK

### to be able to affect the controls, the combined targeting of the treatment miRNAs must be in the majority
hist(sapply(ca.hek$n, length))
abline(v=length(unique(se.hek$miRNA))/2, col="red")

### check what ratio of treatment miRNA are in the TS target list
hist(ca.hek$ratios)
mean(ca.hek$ratios, na.rm=TRUE)
median(ca.hek$ratios, na.rm=TRUE)
```


