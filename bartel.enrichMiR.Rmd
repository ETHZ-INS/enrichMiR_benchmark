---
title: "Bartel enrichMiR analysis"
author: "tgermade"
date: "`r Sys.Date()`"
output:
    html_document:
        toc: true
        toc_float: true
        theme: 'cerulean'
        highlight: 'tango'
        df_print: paged
---

<style>
  .main-container {
    max-width: 1500px !important;
  }
</style>


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries}
suppressPackageStartupMessages({
  library(SummarizedExperiment)
  library(SEtools)
  library(ggplot2)
  library(plgINS)
  library(edgeR)
  library(DT)
  library(viridis)
  library(RColorBrewer)
  library(data.table)
  library(dplyr)
  library(tibble)
  library(cowplot)
  library(matrixStats)
  library(igraph)
  library(RUVSeq)
})
devtools::load_all("~/master_19_20/enrichMiR/enrichMiR/")
```

## Allocation

```{r}

# input file: Bartel DEA SE
#input <- "data/bartel.hela.DEA.SE.rds"
input <- "data/bartel.hek.DEA.SE.rds"

# output file: enrichMiR results
#output.e <- "data/bartel.hela.e.rds"
output.e <- "data/bartel.hek.e.rds"

# number of cores for high runtime functions
cores <- 10
```


## Loading

```{r import hela bartel}

# import
se <- readRDS(input)
```


## Permutations

```{r variables}

# define variables
#treatment <- unique(as.character(se$miRNA))
dea.df.names.all <- colnames(rowData(se)[,grepl("DEA",colnames(rowData(se)))][-2])
dea.names.all <- gsub("DEA.","", dea.df.names.all)
```

```{r dea permutation}

# set number of replicates per permutation proportion
nrep <- 5

# save Bartel DEAs into list
dea.orig <- lapply(rowData(se)[,dea.df.names.all], function(x) x)


# the permuatation proportions that should be computed for each DEA
names(i) <- i <- 1:nrep
props <- unlist(lapply( c("20"=0.2, "30"=0.3, "40"=0.4, "50"=0.5), 
                        FUN=function(x) lapply(i, FUN=function(y) x)))


#' DEAperm
#'
#' @param dea a dataframe of DEA results
#' @param props a vector of proportions for which permutations should be generated
#' @param round a logical: should DEA dataframe be rounded?
#'
#' @return a dataframe of DEA results but randomly permutated according to chosen proportions
#'
DEAperm <- function(dea, props, round=FALSE){
  # round DEA if necessary
  if(round) dea <- plgINS::dround(dea[,-3], roundGreaterThan1 = TRUE)
  # select random rows (i) & reorder them randomly (j)
  lapply(props, FUN=function(p){
    sn <- floor(p*nrow(dea))
    i <- sample(seq_len(nrow(dea)), sn)
    j <- sample(seq_len(sn), sn)
    row.names(dea)[i] <- row.names(dea)[i[j]]
    return(dea)
  })
}

set.seed(1234)
dea.list <- lapply(names(dea.orig), FUN=function(x) DEAperm(dea.orig[[x]], props))
names(dea.list) <- dea.names.all

for(i in 1:length(dea.names.all)){
  dea.list[[i]][["original"]] <- dea.orig[[i]]
}
```


# enrichMiR

```{r load enrichmir package, message=FALSE, warning=FALSE}

# load enrichMiR package
devtools::load_all("~/master_19_20/enrichMiR/enrichMiR/")
```

```{r enrichmir dea function}

#' getDEA
#'
#' @param dea.df dataframe of DEA results (an SE rowData column if generated via DEA() function)
#'
#' @return FDR-filtered dataframe containing c("symbol","logFC","PValue","FDR") columns
#'
getDEA <- function(dea.df){
  if(!any(colnames(dea.df) %in% "symbol")) dea.df$symbol <- rownames(dea.df)
  dea <- as.data.frame(dea.df[,c("symbol","logFC", "logCPM","PValue","FDR")])
  dea <- aggregate(dea[,-1], by=list(symbol=dea$symbol),FUN=mean)
  rownames(dea) <- dea$symbol
  dea <- dea[,-1]
  
  lapply(dea, FUN = function(x){
    if(any(is.infinite(x))){
      w <- which(is.infinite(x))
      x[w] <- max(abs(x[setdiff(which(dea$FDR<0.5),w)]))*sign(x[w])
    }
  })
  return(dea)
}
```

```{r enrichmir dea, message=FALSE, warning=FALSE}

# generate dea object (high runtime!)
#dea.list <- lapply(dea.df.names.all, FUN = function(x) getDEA(rowData(se.hela)[[x]]))

dea.list <- bplapply(dea.list, function(x){lapply(x, function(y) getDEA(y))}, 
                   BPPARAM = MulticoreParam(cores, progressbar = FALSE))

# identify empty dea objects (where nothing significant is found) & exclude
dea.empty <- sapply(dea.list, FUN = function(x) nrow(x[[1]])==0)
dea.names <- dea.names.all[!dea.empty]
dea.df.names <- dea.df.names.all[!dea.empty]

names(dea.list) <- dea.names
```

```{r enrichmir mirexpr}

# we don't use miRNA expression values for the benchmark. This will make it more difficult # for the enrichMiR tests
mirexpr <- NULL
```


```{r get targetscan data function}

#' getTS
#'
#' @param species character object. Can be "human", "mouse" or "rat"
#'
#' @return TargetScan miRNA target dataframe with family information in metadata()
#'
getTS <- function(species=c("human","mouse","rat")){
  library(S4Vectors)
  species <- match.arg(species)
  
  # assign species ID
  spec <- switch( species,
                  human = 9606,
                  mouse = 10090,
                  rat = 10116 )
  
  
  # download TargetScan miRNA targeting dataset
  tmp <- tempfile()
  download.file(
    "http://www.targetscan.org/vert_72/vert_72_data_download/Summary_Counts.all_predictions.txt.zip", 
    tmp)
  unzip(tmp)
  full <- fread("Summary_Counts.all_predictions.txt") #, sep = "\t", header = TRUE)
  
  # limit to selected species
  sub <- full[full$'Species ID' == spec,]
  sub$score <- as.numeric(as.character(sub$'Cumulative weighted context++ score'))
    
  # generate TargetScan dataframe
  ts <- DataFrame(family = sub$'miRNA family',
                   rep.miRNA = sub$'Representative miRNA',
                   feature = sub$'Gene Symbol',
                   sites = sub$'Total num conserved sites',
                   score = as.numeric(as.character(sub$'Cumulative weighted context++ score'))
                   )
  ts <- DataFrame(
    aggregate(sub[,c("sites","score")], by=ts[,c("family","feature")], FUN=mean)
    )
  

  
  # download TargetScan miRNA families dataset
  tmp <- tempfile()
  download.file(
    "http://www.targetscan.org/vert_72/vert_72_data_download/miR_Family_Info.txt.zip", 
    tmp)
  unzip(tmp)
  full <- fread("miR_Family_Info.txt") #, sep = "\t", header = TRUE)
  
  # limit to selected species
  sub <- full[full$'Species ID' == spec,]
  
  fam <- sub$`Seed+m8`
  names(fam) <- sub$`MiRBase ID`
  
  # add family info to ts dataframe as attribute
  metadata(ts)$families <- fam
  
  # enrichMiR cant handle 0 values for sites feature
  return(ts[ts$sites!=0,])
}
```

```{r enrichmir ts, eval=FALSE}

# get TargetScan miRNA targets
TS <- getTS(species = "human")
```

```{r load enrichmir ts}

# load TS object
TS <- readRDS( "data/TargetScan_all.rds")
```

```{r enrichmir e, warning=FALSE, message=FALSE, eval=FALSE}

#tests <- c("areamir","overlap","wo","michael","KS","KS2","MW")
tests <- NULL

# run enrichMiR on all objects of dea.list (high runtime!)
e.list <- lapply(dea.list, FUN = function(x){
  bplapply(x, function(y){
    enrichMiR(DEA=as.data.frame(y), TS=TS, miRNA.expression=mirexpr, 
                         cleanNames=TRUE, tests=tests)
  }, BPPARAM = MulticoreParam(cores, progressbar = TRUE) )
})

names(e.list) <- dea.names
```

```{r save enrichmir e, eval=FALSE}

# place original DEA at 1st position for each treatment
for(i in 1:length(e.list)){
  e.list[[i]] <- e.list[[i]][c("original", names(props))]
}

# save e object
saveRDS(e.list, output.e)
```

```{r load enrichmir e}

# load TS object
e.list <- readRDS(output.e)
```


## Benchmarking

```{r benchmarking 1 function, message=FALSE, warning=FALSE, eval=FALSE}

dat <- function(e, thresholds, TP){
  dplyr::bind_rows(
    lapply(e@res, FUN=function(x){
      if("family" %in% colnames(x)) row.names(x) <- x$family
      x$truth <- row.names(x) %in% TP
      x$FDR[is.na(x$FDR)] <- 1
      as.data.frame(
        t(sapply(thresholds, FUN=function(i){
          P <- sum(x$FDR<=i)
          c( threshold=i,
             P=P,
             TP=sum(x$FDR<=i & x$truth),
             FP=sum(x$FDR<=i & !x$truth),
             TPR=sum(x$FDR<=i & x$truth)/sum(x$truth),
             FPR=sum(x$FDR<=i & !x$truth)/sum(!x$truth),
             FDR=ifelse(P>0,sum(x$FDR<=i & !x$truth)/P,0) )
          }))
        )
      }), .id="method")
}

```

```{r benchmarking 1, message=FALSE, warning=FALSE, eval=FALSE}

# Benchmarking

devtools::load_all("../enrichMiR/enrichMiR/")
fams <- metadata(TS)$families

#dea <- deas[[1]]
#dea <- rowData(se.hela)$`DEA.let-7a`
#e <- enrichMiR(dea, TS)
#e <- e.list$`miR-122`

#TP <- unique(as.character(fams[grep("miR-144$|miR-144-",names(fams))]))
thresholds <- c(0,10^(-10:-3),0.005,0.01,0.025,0.05,0.075,0.1,0.15,0.2,0.25,0.3,0.5)

# get benchmark results
dat.list <- lapply(dea.names[1], FUN=function(x) lapply(names(e.list[[x]]), FUN=function(y) dat(e.list[[x]][[y]], thresholds, TP.list[[x]]) ))

ggplot(dat.list[[1]][[2]], aes(FPR, TPR, colour=method)) + geom_line() + geom_point(size=3) + 
  scale_x_log10()  
#+ scale_colour_manual(values=cols)

```

```{r benchmarking 2 function, message=FALSE, warning=FALSE, eval=TRUE}

#' doBenchmark
#'
#' @param res enrichMiR test results (e object)
#' @param TP character vector: contains the seeds (families) for a miRNA treatment
#'
#' @return a dataframe containing scores for each enrichMiR test
#'
doBenchmark <- function(res, TP){
  res <- lapply(res, FUN=function(x){
    x <- x[order(x$FDR),]
    if("family" %in% colnames(x)) row.names(x) <- x$family
    x$truth <- row.names(x) %in% TP
    x$FDR[is.na(x$FDR)] <- 1
    x
  })
  data.frame( method=names(res),
              detPPV = sapply(res, FUN=function(x) 1/which(x$truth)[1] ),
              FP.atFDR05 = sapply(res, FUN=function(x) sum(!x$truth & x$FDR<0.05)),
              log10QDiff = sapply(res, FUN=function(x){
                tp1 <- -log10(x$FDR[which(x$truth)[1]])
                fp1 <- -log10(x$FDR[which(!x$truth)[1]])
                tp1-fp1
              }),
              log10QrelIncrease = sapply(res, FUN=function(x){
                tp1 <- -log10(x$FDR[which(x$truth)[1]])
                fp1 <- -log10(x$FDR[which(!x$truth)[1]])
                (tp1-fp1)/(min(tp1,fp1))
              }))
  
}
```

```{r benchmarking 2, message=FALSE, warning=FALSE, eval=TRUE, fig.width=10}

fams <- metadata(TS)$families

# for each treatment miRNA select the seed families they belong to (they are the True Positives)
TP.list <- lapply(
  dea.names, FUN=function(x) unique(as.character(
    fams[grepl(paste0(x,"-"), names(fams)) | grepl(paste0(x,"$"), names(fams))]))
  )
names(TP.list) <- dea.names

# generate the benchmarking scores
BM.list <- lapply(dea.names, FUN=function(x){
  lapply(names(e.list[[x]]), FUN=function(y){
    doBenchmark(e.list[[x]][[y]]@res, TP.list[[x]]) 
    })
})
# naming
names(BM.list) <- dea.names
for(x in dea.names){
  names(BM.list[[x]]) <- names(e.list[[x]])
}

# # create variables for benchmark dataframe
# props.all <- c("original", props)
# methods <- rownames(BM.list[[1]][[1]])
# # create benchmark dataframe
# df1 <- data.frame(methods = rep(methods, length(props.all)*length(dea.names)),
#                  treatment = unlist(lapply( dea.names, FUN=function(x) 
#                    rep(x,length(methods)*length(props.all)) )),
#                  props.all = rep( 
#                    c(rep("original",length(methods)), 
#                      sapply(unique(props), rep, length(methods)*nrep)), length(dea.names))
#                  )
# df2.list <- lapply(BM.list, function(x) stack(sapply(x, function(y) y[,"detPPV"])))
# df2 <- do.call("rbind", df2.list)
# colnames(df2)[2:3] <- c("props","score")
# 
# BM.df <- as.data.frame(cbind(df1, df2))
# levels(BM.df$props.all) <- c("original", unique(props))
# 
# BM.agg <- aggregate(BM.df$score, by=BM.df[,c("props","props.all","methods")], FUN=mean)
# colnames(BM.agg)[4] <- "score"


BM.list2 <- lapply(BM.list, FUN=function(x) dplyr::bind_rows(x, .id = "prop.rep"))
BM.df <- dplyr::bind_rows(BM.list2, .id="treatment")
BM.df$prop <- unlist(lapply(strsplit(BM.df$prop.rep, "[.]"), FUN=function(x) x[1]))
BM.df$prop <- factor(BM.df$prop, levels=unique(BM.df$prop))
#                     levels=c("original", levels(BM.df$prop)[-length(levels(BM.df$prop))]))
# # check some stats
# ## score distribution per treatment
# lapply(dea.names, function(x) hist(log10(BM.df$score[BM.df$treatment==x]), main=x, xlab="log10(score)"))
# ## score distribution per permutation
# lapply(c("original",unique(props)), function(x) hist(log10(BM.df$score[BM.df$props.all==x]), main=x, xlab="log10(score)"))
# ## score distribution per test method
# lapply(methods, function(x) hist(log10(BM.df$score[BM.df$methods==x]), main=x, xlab="log10(score)"))



df <- BM.df
#df <- BM.agg
#df <- BM.df[BM.df$props!="original",]
#df <- BM.agg[BM.agg$props!="original",]
#df <- BM.df[BM.df$props=="original",]
#df <- BM.df[BM.df$props.all %in% c("original",.4),]

# trying out different plots
p <- ggplot(df, aes(x=prop, y=detPPV, fill=method)) 
## boxplot
p + geom_boxplot()
## violin plot
p + geom_violin() #+ geom_dotplot(binaxis='y', stackdir='center', binwidth = .001, position=position_dodge(1))

## density plot:
### score distribution per permutation
ggplot(df, aes(log10(detPPV))) + geom_density(aes(fill=method), alpha=0.9)  + facet_wrap(~prop)
### score distribution per method
ggplot(df, aes(log10(detPPV))) + geom_density(aes(fill=prop), alpha=0.9)  + facet_wrap(~method)
### score distribution per treatment
ggplot(df, aes(log10(detPPV))) + geom_density(aes(fill=method), alpha=0.9)  + facet_wrap(~treatment)
  
## counts plot  
ggplot(df, aes(x=method, y=detPPV, fill=method)) + 
  geom_count(show.legend=F, aes(colour=method)) + facet_wrap(~prop)

## smoothed lines plot
# ggplot(df, aes(x=props.all, y=detPPV, colour=methods)) + 
#   geom_smooth() + facet_wrap(~treatment)


# reduce BM
#df <- BM.df[BM.df$methods %in% c("aREAmir","MW", "EN.down"),]
#df <- BM.df[BM.df$props.all==.2,]

## reduced violin plot
ggplot(df, aes(x=prop, y=detPPV, fill=method))  + geom_violin() + facet_wrap(~method) +
  guides(fill=FALSE)
```

```{r dea prep bartel intron/exon, eval=FALSE}

<<<<<<< HEAD
# load splice SE (the individual HeLa & HEK datasets are only used for colData generation)
se.splice <- readRDS("data/raw/bartel.splice.raw.SE.rds")
se.hela <- readRDS( "data/bartel.hela.DEA.SE.rds")
se.hek <- readRDS("data/bartel.hek.DEA.SE.rds")

##### DONT FORGET TO FILTER
filter <- c(10,2)
se.splice <- se.splice[which(rowSums(assay(se.splice) >= filter[1]) >= filter[2]),]
=======
# load splice SE
se.splice <- readRDS("data/raw/bartel.splice.raw.SE.rds")
>>>>>>> fb7591f98c3390aa1d21146de9c55f0ab3e264e6

# create colData info for splice SE
colData(se.splice) <- cbind(colData(se.splice), rbind(colData(se.hela), colData(se.hek))[colnames(se.splice),1:3])

# create logcpm assays for both spliced & unspliced assays
<<<<<<< HEAD
# assays(se.splice)$logcpm.spliced <- log1p(cpm(calcNormFactors(DGEList(assays(se.splice)$spliced))))
# 
# assays(se.splice)$logcpm.unspliced <- log1p(cpm(calcNormFactors(DGEList(assays(se.splice)$unspliced))))




#' spliceCombine
#'
#' generates control samples out of the average values over all supplied samples & combines spliced and unspliced
#' assays into one DGEList object. The generated dds & dd objects are used directly in a for DEA: generation of 
#' 
#'
#' @param se SummarizedExperiment object containing assays of raw counts of spliced & unspliced tx
#'
#' @return a DGEList object of combined spliced and unspliced data & a dataframe containing the input SE colData()
#' 
spliceCombine <- function(se){
  
  # allocation
  e1 <- assays(se)$spliced
  e2 <- assays(se)$unspliced
  readtype1 <- "spliced"
  readtype2 <- "unspliced"
  
  # create logcpm assays for both spliced & unspliced assays
  assays(se)$logcpm.spliced <- log1p(cpm(calcNormFactors(DGEList(assays(se)$spliced))))
  assays(se)$logcpm.unspliced <- log1p(cpm(calcNormFactors(DGEList(assays(se)$unspliced))))
  
  # calculate logCPM & logFC values
  if( !any(grepl("logcpm", assayNames(se))) ){
    assays(se)$logcpm.spliced <- log1p(cpm(calcNormFactors(DGEList(assays(se)$spliced))))
    assays(se)$logcpm.unspliced <- log1p(cpm(calcNormFactors(DGEList(assays(se)$unspliced))))
  }
=======
assays(se.splice)$logcpm.spliced <- log1p(cpm(calcNormFactors(DGEList(assays(se.splice)$spliced))))

assays(se.splice)$logcpm.unspliced <- log1p(cpm(calcNormFactors(DGEList(assays(se.splice)$unspliced))))


#se.splice.hela <- se.splice[,se.splice$Cell_Line=="HeLa"]
#se.splice.hek <- se.splice[,se.splice$Cell_Line!="HeLa"]



spliceCombine <- function(se){
  
  # if(spliced){logcpm <- "logcpm.spliced"; readtype <- "spliced" 
  # } else {logcpm <- "logcpm.unslpliced"; readtype <- "unspliced"}

  e1 <- assays(se)$spliced
  e2 <- assays(se)$unspliced
  logcpm1 <- "logcpm.spliced"
  logcpm2 <- "logcpm.unspliced"
  readtype1 <- "spliced"
  readtype2 <- "unspliced"
  
>>>>>>> fb7591f98c3390aa1d21146de9c55f0ab3e264e6
  
  # generate a 'control' sample out of the median normalized counts over all samples
  genCTRL <- function(se, logcpm){
    e.ctrl <- sapply(unique(se$Batch), ls=min(colSums(assay(se))), 
                           FUN=function(x,ls){
<<<<<<< HEAD
                             rowMedians(exp(assays(se)[[logcpm]][,se$Batch==x])-1) * ls/1000000
=======
                             rowMedians(exp(assays(se)[[logcpm]][,se$Batch==x])-1) *
                               ls/1000000
>>>>>>> fb7591f98c3390aa1d21146de9c55f0ab3e264e6
                             }
                           )
    ## generate colnames
    n.cols <- sapply( unique(se$Batch), FUN=function(x)
      var_name <- paste("CTRL", x, sep=".") )
    colnames(e.ctrl) <- n.cols
    rownames(e.ctrl) <- rownames(se)
    return(e.ctrl)
  }
  
<<<<<<< HEAD
  e.ctrl1 <- genCTRL(se, logcpm.spliced)
  e.ctrl2 <- genCTRL(se, logcpm.unspliced)
  
  se <- SEtools::log2FC(se, controls = se$miRNA=="CTRL", by = paste(se$Batch, se$readtype), fromAssay = "logcpm")
}

se.hela <- se.splice[,se.splice$Cell_Line=="HeLa"]
se.hek <- se.splice[,se.splice$Cell_Line=="HEK293FT"]
se.splice.hela <- DEA(se.hela, use = se.hela$miRNA %in% c("CTRL","miR-144"), name = "spliced.miR-144", 
                      model = ~readtype*miRNA, model0 = ~readtype+miRNA)
se.splice.hek <- DEA(se.hek, use = se.hek$miRNA %in% c("CTRL","miR-122"), name = "spliced.miR-122", 
                      model = ~readtype*miRNA, model0 = ~readtype+miRNA)









=======
  e.ctrl1 <- genCTRL(se, logcpm1)
  e.ctrl2 <- genCTRL(se, logcpm2)
  
>>>>>>> fb7591f98c3390aa1d21146de9c55f0ab3e264e6
  # add control samples to assays & generate DGEList object
  dds1 <- DGEList(cbind(e1, e.ctrl1))
  dds2 <- DGEList(cbind(e2, e.ctrl2))
  
  # combine the spliced & unspliced assays
  dds <- cbind(dds1, dds2)

  # generate colData info for combined assay
  dd1 <- colData(se)[,c("Batch","miRNA","Cell_Line")]
  dd.ctrl1 <- data.frame(
    Batch=unique(se$Batch), miRNA="CTRL", Cell_Line=unique(as.character(dd1$Cell_Line)) )
  dd1 <- rbind(dd1, dd.ctrl1)
  dd1$readtype <- readtype1
  
  # duplicate dd to have data for combined spliced & unspliced assay
  dd <- rbind(dd1, dd1)
  dd$readtype[(nrow(dd1)+1):nrow(dd)] <- readtype2
  dd$readtype <- as.factor(dd$readtype)
  
  # rename both dds & dd object features
  n.cols1 <- sapply(colnames(dds1), FUN=function(x)
      var_name <- paste(x, readtype1, sep=".") )
  n.cols2 <- sapply(colnames(dds2), FUN=function(x)
      var_name <- paste(x, readtype2, sep=".") )
  
  colnames(dds) <- c(n.cols1, n.cols2)
  rownames(dd) <- c(n.cols1, n.cols2)
  
<<<<<<< HEAD
  # return(list(dds=dds, dd=dd))
  
  # DEA
  
  dd$miRNA <- relevel(droplevels(dd$miRNA), ref="CTRL")
  dd$readtype <- relevel(dd$readtype, ref="unspliced")
  ## To do the normalization
  dds <- calcNormFactors(dds)
  ## models
  mm <- model.matrix(~readtype*miRNA, data=dd)
  mm0 <- model.matrix(~readtype+miRNA, data=dd)
  testCoeff <- setdiff(colnames(mm), colnames(mm0))
  ## estimate dispersion
  dds <- estimateDisp(dds,mm)
  ## fit negative binomial distribution on counts per gene (use glmFit for few replicates)
  fit <- glmFit(dds, mm)
  ## fit a GLM on the data
  lrt.comb <- glmLRT(fit, testCoeff)
  ## top genes that change relative to stage 0
  res.comb <- as.data.frame(topTags(lrt.comb, Inf))
  ## fit linear model dropping one sample at a time (using multiple cores)
  res.list <- bplapply( testCoeff, BPPARAM=MulticoreParam(8), FUN=function(x){
    as.data.frame(topTags(glmLRT(fit, x),Inf))
  })
  # names(res.list) <- testCoeff
  dea_name <- paste0("DEA.", name)
  rowData(se)$DEA.all <- as.data.frame(res.comb)
  rowData(se)[[testCoeff[i]]] <- as.data.frame(res.list[[i]])
  
  return(se)
  
  
  refIDs <- colnames(se.sub)[1:sum(mm[,2])]
  assays(se)$logFC.spliced <- assays(se)$logcpm.spliced - rowMeans(assays(se)$logcpm.spliced[,refIDs])
  assays(se)$logFC.unspliced <- assays(se)$logFC.unspliced - rowMeans(assays(se)$logFC.unspliced[,refIDs])

=======
  
  return(list(dds=dds, dd=dd))
>>>>>>> fb7591f98c3390aa1d21146de9c55f0ab3e264e6
}

# select SE & assay (spliced or unspliced)
se <- se.splice

# get dds (DGEList object) & dd (DataFrame) for both HEK & HeLa cell lines
d.hela <- spliceCombine(se.splice[,se.splice$Cell_Line=="HeLa"])
d.hek <- spliceCombine(se.splice[,se.splice$Cell_Line=="HEK293FT"])


<<<<<<< HEAD
dds.list <- list(d.hela$dds, d.hek$dds)
dd.list <- list(d.hela$dd, d.hek$dd)

# DEA function
spliceDEA <- function(dds, dd){
  dd$miRNA <- relevel(droplevels(dd$miRNA),"CTRL")
  dd$readtype <- relevel(dd$readtype, "unspliced")
=======
# DEA
dds.list <- list(d.hela$dds, d.hek$dds)
dd.list <- list(d.hela$dd, d.hek$dd)

dea.list <- lapply(1:length(dds.list), FUN=function(i) 
  spliceDEA(dds.list[[i]], dd.list[[i]]))

spliceDEA <- function(dds, dd){
>>>>>>> fb7591f98c3390aa1d21146de9c55f0ab3e264e6
  ## To do the normalization
  dds <- calcNormFactors(dds)
  ## models
  mm <- model.matrix(~readtype*miRNA, data=dd)
  mm0 <- model.matrix(~readtype+miRNA, data=dd)
  testCoeff <- setdiff(colnames(mm), colnames(mm0))
  ## estimate dispersion
  dds <- estimateDisp(dds,mm)
<<<<<<< HEAD
  ## fit negative binomial distribution on counts per gene (use glmFit for few replicates)
  fit <- glmFit(dds, mm)
  ## fit a GLM on the data
  lrt.comb <- glmLRT(fit, testCoeff)
  ## top genes that change relative to stage 0
  res.comb <- as.data.frame(topTags(lrt.comb, Inf))
  ## fit linear model dropping one sample at a time (using multiple cores)
  res.list <- bplapply( testCoeff, BPPARAM=MulticoreParam(8), FUN=function(x){
    as.data.frame(topTags(glmLRT(fit, x),Inf))
  })
  # names(res.list) <- testCoeff
  dea_name <- paste0("DEA.", name)
  rowData(se)$DEA.all <- as.data.frame(res.comb)
  rowData(se)[[testCoeff[i]]] <- as.data.frame(res.list[[i]])
  
  return(se)
}


dea.splice.list <- bplapply(seq_along(dds.list), FUN=function(i){
  spliceDEA(dds.list[[i]], dd.list[[i]])
  }, BPPARAM = MulticoreParam(2, progressbar = TRUE) )
names(dea.splice.list) <- c("hela","hek")



# generate SE objects
SEs <- lapply(seq_along(dd.list), FUN=function(i){
  se <- SummarizedExperiment(assays =  list(counts=dds.list[[i]]$counts), 
                                       rowData = dea.splice.list[[i]], colData = dd.list[[i]])
  assays(se)$logcpm <- log1p(cpm(calcNormFactors(DGEList(assay(se)))))
  se <- SEtools::log2FC(se, controls = se$miRNA=="CTRL", by = paste(se$Batch, se$readtype), fromAssay = "logcpm")
  se
})
names(SEs) <- c("hela","hek")
SEtools::sehm(SEs$hela, row.names(dea.splice.list$hela)[dea.splice.list$hela$FDR < 0.01], gaps_at = "readtype",
breaks=T, do.scale = T, show_colnames = TRUE, assayName = "log2FC")
=======
  ## fit negative binomial distribution on counts per gene
  fit <- glmQLFit(dds, mm)
  ## fit a GLM on the data
  lrt <- glmQLFTest(fit, testCoeff)
  ## top genes that change relative to stage 0
  res <- as.data.frame(topTags(lrt, Inf))
  ## fit linear model dropping one sample at a time (using multiple cores)
  dea.list.hela <- bplapply( levels(dd$miRNA)[-1], BPPARAM=MulticoreParam(8), FUN=function(x){
    as.data.frame(topTags(glmLRT(fit, paste0("miRNA",x)),Inf))
  })
  names(dea.list.hela) <- levels(dd$miRNA)[-1]
}


dds <- calcNormFactors(dds)
mm <- model.matrix(~Batch+miRNA, data=dd)
dds <- estimateDisp(dds,mm)
fit <- glmFit(dds,mm)
## fit linear model dropping one sample at a time (using multiple cores)
dea.list.hela <- bplapply( levels(dd$miRNA)[-1], BPPARAM=MulticoreParam(8), FUN=function(x){
  as.data.frame(topTags(glmLRT(fit, paste0("miRNA",x)),Inf))
})
names(dea.list.hela) <- levels(dd$miRNA)[-1]
>>>>>>> fb7591f98c3390aa1d21146de9c55f0ab3e264e6
```

