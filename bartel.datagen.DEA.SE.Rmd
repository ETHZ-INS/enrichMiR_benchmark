---
title: "bartel DEA SE generation"
author: "tgermade"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    theme: 'cerulean'
    highlight: 'tango'
    df_print: paged
---
  
<style>
  .main-container {
    max-width: 1500px !important;
  }
</style>
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries, warning=FALSE, message=FALSE}

suppressPackageStartupMessages({
  library(edgeR)
  library(SummarizedExperiment)
  library(SEtools)
})
```

## Allocation

```{r allocation}

# allocation

## filter: AT LEAST how many counts in AT LEAST how many samples? e.g. counts >= 20, samples >= 2
sel <- c(10, 2)
## input file
input <- "data/raw/bartel_symbols.raw.SE.rds"
## output files
output1 <- "data/bartel.hela.DEA.SE.rds"
output.no_round1 <- "data/bartel_noRound.hela.DEA.SE.rds"
output2 <- "data/bartel.hek.DEA.SE.rds"
output.no_round2 <- "data/bartel_noRound.hek.DEA.SE.rds"
```


## Loading

```{r load se, warning=FALSE, message=FALSE}

# load raw SE file
se <- readRDS(input)
```

```{r separate celltypes bartel, warning=FALSE, message=FALSE}

# get logcpm values & factorize Batch info
assays(se)$logcpm <- log1p(cpm(calcNormFactors(DGEList(assay(se)))))
se$Batch <- factor(se$Batch)

# separate the 2 cell lines
se.hela <- se[,se$Cell_Line=="HeLa"]
se.hela <- se.hela[rowSums(assay(se.hela) >= sel[1]) >= sel[2],]
se.hek <- se[,se$Cell_Line!="HeLa"]
se.hek <- se.hek[rowSums(assay(se.hek) >= sel[1]) >= sel[2],]
```


## PCA

Question: should we correct for batch?

```{r pca bartel, warning=FALSE, message=FALSE}

# plot PCA

## combined
plgINS::plPCA(assays(se)$logcpm, as.data.frame(colData(se)), colorBy = "Cell_Line", 
              add.labels = FALSE, annotation_columns = colnames(colData(se))[1:3])

## HeLa 
p.hela <- plgINS::plPCA(assays(se.hela)$logcpm, as.data.frame(colData(se.hela)), 
                   colorBy = "miRNA", shapeBy = "Batch", add.labels = FALSE, 
                   annotation_columns = colnames(colData(se.hela))[1:3])
add_markers(p.hela, color = ~se.hela$miRNA, colors = "Paired")

## HeLa batch effect
plgINS::plPCA(assays(se.hela)$logcpm, as.data.frame(colData(se.hela)), colorBy = "Batch",
              add.labels = FALSE, annotation_columns = colnames(colData(se.hela))[1:3])

## HEK
p.hek <- plgINS::plPCA(assays(se.hek)$logcpm, as.data.frame(colData(se.hek)), 
                       colorBy = "miRNA", shapeBy = "Batch", add.labels = FALSE,
                       annotation_columns = colnames(colData(se.hek))[1:3])
add_markers(p.hek, color = ~se.hek$miRNA, colors = "Paired")

## HEK batch effect
plgINS::plPCA(assays(se.hek)$logcpm, as.data.frame(colData(se.hek)), colorBy = "Batch", 
              add.labels = FALSE, annotation_columns = colnames(colData(se.hek))[1:3])
```

Batch correction for HeLa cells: definitely.  
Batch correction for HEK cells: maybe not necessary. Let's compare both DEAs.  


## DEA

```{r generate control function}

#' genCTRL
#'
#' @param se SE object
#' @param logcpm character: name of the logcpm assay contained in supplied SE object
#'
#' @return matrix: control samples generated out of existing samples, one for each batch
#'
genCTRL <- function(se, logcpm){
  # e.ctrl <- sapply(unique(se$Batch), ls=min(colSums(assay(se))),
  #                        FUN=function(x,ls){
  #                          rowMedians(exp(assays(se)[[logcpm]][,se$Batch==x])-1) * ls/1000000
  #                          }
  #                        )
  e.ctrl <- sapply(unique(se$Batch), ls=colSums(assay(se)),
                         FUN=function(x,ls){
                           rowMedians(expm1(assays(se)[[logcpm]][,se$Batch==x])) * median(ls[se$Batch==x])/1000000
                           }
                         )

  ### generate colnames
  n.cols <- sapply( unique(se$Batch), FUN=function(x) var_name <- paste("CTRL", x, sep=".") )
  colnames(e.ctrl) <- n.cols
  rownames(e.ctrl) <- rownames(se)
  return(e.ctrl)
  }
```


```{r dea bartel function, message=FALSE, warning=FALSE}

#' bartelDEA
#'
#' Generates control samples out of the average values over all supplied samples,
#' calculates their logCPM & log2FC data and performs DEA over all treatments & individual ones. 
#' All is assembled into one SE object. 
#' 
#'
#' @param se SummarizedExperiment object containing assays of raw counts
#'
#' @return an SE object
#' 
bartelDEA <- function(se, model, model0=~1){

  se$Batch <- droplevels(se$Batch)
  
  # generate control
    
  ## create logcpm assay
  assays(se)$logcpm <- log1p(cpm(calcNormFactors(DGEList(assay(se)))))
  
  ## generate a 'control' sample out of the median normalized counts over all samples
  e.ctrl <- genCTRL(se, "logcpm")
  
  ## add control samples to assays & generate DGEList object
  dds <- DGEList(cbind(assay(se), e.ctrl))
  
  ## generate colData info for combined assay
  dd <- rbind(colData(se)[,c("Batch","miRNA","Cell_Line")], data.frame(Batch=unique(se$Batch),
                                                                       Cell_Line=unique(se$Cell_Line),
                                                                       miRNA="CTRL"))
  dd$miRNA <- relevel(droplevels(dd$miRNA), ref="CTRL")
  
  
  # DEA
  
  ## normalization
  dds <- calcNormFactors(dds)
  ## models
  mm <- model.matrix(model, data=dd)
  mm0 <- model.matrix(model0, data=dd)
  testCoeff <- setdiff(colnames(mm), colnames(mm0))
  ## estimate dispersion
  dds <- estimateDisp(dds,mm)
  ## fit negative binomial distribution on counts per gene (use glmFit for few replicates)
  fit <- glmFit(dds,mm)
  
  ## fit linear model on all samples
  res <- as.data.frame(topTags(glmLRT(fit, testCoeff),Inf))
  
  ## fit linear model dropping one sample at a time (using multiple cores)
  res.list <- bplapply( testCoeff, BPPARAM=MulticoreParam(8), FUN=function(x){
    as.data.frame(topTags(glmLRT(fit, x), Inf))
  })
  
  dea.names <- make.names(gsub("miRNA","", testCoeff))
  names(res.list) <- paste0("DEA.",dea.names)
  colnames(res)[grepl("logFC",colnames(res))] <- paste0("logFC.", dea.names)
  
  
  # generate final SE object
  
  ## SE object with logCPM & logFC assays & batch-corrected logCPM assays (for visualization)
  se <- SummarizedExperiment(assays=list(counts=dds$counts), 
                             rowData=rowData(se), 
                             colData=dd) 
  assays(se)$logcpm <- log1p(cpm(calcNormFactors(DGEList(assay(se)))))
  se <- SEtools::log2FC(se, controls = se$miRNA=="CTRL", by = paste(se$Batch), fromAssay = "logcpm")
  assays(se)$corrected <- sva::ComBat(assays(se)$logcpm, batch = se$Batch, 
                                      model.matrix(~se$miRNA))

  ## add DEAs
  rowData(se)$DEA.all <- DataFrame(res[rownames(se),])
  for(i in paste0("DEA.",dea.names)){
    rowData(se)[[i]] <- DataFrame(res.list[[i]][rownames(se),])
  }
  
  
  # output
  
  return(se)
}
```

```{r dea bartel, message=FALSE, warning=FALSE}

# DEA HeLa
se.hela <- bartelDEA(se.hela, model = ~Batch+miRNA, model0 = ~Batch)

# DEA HEK
se.hek <- bartelDEA(se.hek, model = ~Batch+miRNA, model0 = ~Batch)

# DEA HEK without taking batch effect into account
se.hek.nb <- se[,se$Cell_Line!="HeLa"]
se.hek.nb <- se.hek.nb[rowSums(assay(se.hek.nb) >= sel[1]) >= sel[2],]
se.hek.nb <- bartelDEA(se.hek.nb, model = ~1+miRNA)
```


## check results

```{r sig tx changes bartel, message=FALSE, warning=FALSE}

# select significant gene expression changes
degs.hela <- lapply(rowData(se.hela)[grepl("DEA.",colnames(rowData(se.hela)))], FUN=function(x) row.names(x)[x$FDR<0.05])
degs.hek <- lapply(rowData(se.hek)[grepl("DEA.",colnames(rowData(se.hek)))], FUN=function(x) row.names(x)[x$FDR<0.05])
degs.hek.nb <- lapply(rowData(se.hek.nb)[grepl("DEA.",colnames(rowData(se.hek.nb)))], FUN=function(x) row.names(x)[x$FDR<0.05])

# number of significant gene expression changes per sample
## HeLa
sapply(degs.hela,length)
## HEK
sapply(degs.hek,length)
## HEK no batch correction
sapply(degs.hek.nb,length)
```

```{r hek comparison bartel, message=FALSE, warning=FALSE}

# comparison of HEK DEA with and without batch effect taken into account
## median number of significant changes: HEK w batch
median(unlist(lapply(degs.hek,length)))
## median number of significant changes: HEk w/out batch
median(unlist(lapply(degs.hek.nb,length)))
## which proportion of significant tx do we see in batch vs no batch and vice versa
## e.g. for miR-122 63% of tx found in batch corrected DEA are also found in uncorrected 
dea.names <- colnames(rowData(se.hek)[grepl("DEA.",colnames(rowData(se.hek)))])
t(sapply(dea.names, FUN = function(x){
  b_in_nb <- sum(degs.hek[[x]] %in% degs.hek.nb[[x]])/length(degs.hek[[x]])
  nb_in_b <- sum(degs.hek.nb[[x]] %in% degs.hek[[x]])/length(degs.hek.nb[[x]])
  c(b_in_nb=b_in_nb, nb_in_b=nb_in_b)
}))
```

We get more significant results with the batch corrected HEK DEA & almost all significant tx of the batch uncorrected HEK DEA are present in the corrected one. We thus choose the batch corrected version.  


## Export

```{r export hela bartel, warning=FALSE, message=FALSE}

# export HeLa noRound
saveRDS(se.hela, output.no_round1)
# round
source("functions/roundSE.R")
se.hela <- roundSE(se.hela)
# export HeLa
saveRDS(se.hela, output1)
```

```{r import hela bartel, warning=FALSE, message=FALSE}

# import HeLa
se.hela <- readRDS(output.no_round1)
```

```{r export hek no batch bartel, warning=FALSE, message=FALSE}

# export HEK noRound
saveRDS(se.hek, output.no_round2)
# round
source("functions/roundSE.R")
se.hek <- roundSE(se.hek)
# export HEK
saveRDS(se.hek, output2)
```

```{r import hek no batch bartel, warning=FALSE, message=FALSE}

# import HEK
se.hek <- readRDS(output.no_round2)
```


## Heatmaps

```{r hm bartel}

# heatmaps: comparing batch uncorrected vs corrected

## HeLa logcpm
sehm(se.hela[,order(se.hela$miRNA)], degs.hela$DEA.miR.143, do.scale = TRUE, 
     anno_columns = c("miRNA","Batch"), assayName = "logcpm", 
     show_rownames = FALSE, breaks = TRUE)

## HeLa logcpm batch corrected
sehm(se.hela[,order(se.hela$miRNA)], degs.hela$DEA.miR.143, do.scale = TRUE, 
     anno_columns = c("miRNA","Batch"), assayName = "corrected", 
     show_rownames = FALSE, breaks = TRUE)

## HEK logcpm
sehm(se.hek[,order(se.hek$miRNA)], degs.hek$DEA.miR.184, do.scale = TRUE, 
     anno_columns = c("miRNA","Batch"), assayName = "logcpm", 
     show_rownames = FALSE, breaks = TRUE)

## HEK logcpm batch corrected
sehm(se.hek[,order(se.hek$miRNA)], degs.hek$DEA.miR.184, do.scale = TRUE, 
     anno_columns = c("miRNA","Batch"), assayName = "corrected", 
     show_rownames = FALSE, breaks = TRUE)
```